# Malloc Lab 实验报告

致理-信计01  姚嘉宸  2020012700

## 设计思路

这里我采用的方法是“分离的空闲列表”（segregated free lists），灵感来源于CSAPP 9.9.14。

它的思想是，维护多个有序的空闲列表，其中每个链表中的块有大致相等的大小。这里我使用按照2的幂来划分块的大小，即`{1}, {2, 3}, {4, 5, 6, 7}, ...`这样分组。

对于每组，维护一个空闲列表，列表内按照块大小升序排序。当尝试分配一个大小为 n 的块时，查找到 n 所属的空闲列表，然后遍历并找到第一个大于等于 n 的块；如果没有，则去更大的列表里找。

假设我们找到了大小为 m(>=n) 的空闲块，则尝试将其分为 n 和 m-n 两部分，并将后者插回空闲列表中。

对于 free 操作，为了减少内存碎片，我们尝试将该块与前后的空闲块合并（coalesce）后再插入空闲列表中。

## 数据结构

下面来设计空闲块的结构。对于每一块，需要要记录它的大小和分配情况，我们将块大小储存在头部。注意到块大小一定是8的倍数，因此后3bit一定为0，我们可以在其上储存信息，例如，该块是否分配。对于空闲块，由于它在链表中，因此我们还需要两个WORD存放前后指针。

为了允许前后空闲块合并，我们需要得到前后块的信息。由于本块大小已知，因此后一块的信息比较容易获取。对于访问前一块，一种简单的方法是在每块的尾部附加上块大小。

块结构图示：

![image-20211209004914246](https://img.i207m.top/2021/12_46da6259109d5ec4e6541066f0c5c84d.png)

由于空闲块最少需要4 WORD，因此在分配时每一块的大小至少是4 WORD。（本实验为32位程序，定义WORD=4 bytes）

## 实现细节

可以将反复调用的与指针相关的操作用宏定义，来简化代码难度。

除了需要实现的三个函数以外，我们还要实现三个辅助函数，它们的功能如下：

```cpp
/* 划分空块 */
static void *allocate_on_free_node(void *bp, size_t size);
/* 扩展堆，获得新的空块 */
static void *new_node(size_t size);
/* 将块插入列表 */
static void insert_node(void *bp, size_t size);
/* 将块从列表中删除 */
static void delete_node(void *bp);
/* 尝试将块与前后空块合并，默认此时 bp 未插入列表 */
static void *coalesce(void *bp);
```

对于`allocate_on_free_node`划分空块，需要注意，若划分后剩余块大小小于4 WORD，那么剩下的空间是无法再分配的，不如全部分配给当前请求。

对于 realloc 操作，我们要先判断：当前块之后是否是空闲块 或 当前块在堆顶。此时，我们可以尝试将当前块延长，而不是先 malloc 再 free。

注意要在堆的最前和最后加两个边界，来防止尝试访问相邻块时溢出边界。

## 优化过程

- 由于我们使用2的幂来分组，因此我们可以通过`31 - __builtin_clz(size)`来快速定位，即取 log 上取整。
- 注意到程序在测试点`binary-bal.rep`上的利用率较低，观察它的特点是大块小块的 malloc 交替进行，然后把大块 free 掉。此时内存中有大量的间隔，但是对于新插入更大的块，那些间隔无法使用，只能新申请，由此造成利用率低。我的改进方法是，我们尝试将块分为大块和小块两类，对于小块，优先从前向后分配，对于大块，优先从后向前分配。这样，对于上述情况，大小块在内存中不会交替出现了。

### 更多的潜在优化

- 每个块的尾部信息可以去掉，取而代之的是在头部的倒数第二个bit记录“前一块是否分配”。

- 程序对于realloc较多的情况，内存利用率不高。我的改进想法是，假设有些块会更频繁地realloc，对于这些块，我们可以在每次realloc时加一些padding，由此可以避免每次都要先 malloc 再 free。注意到头部3个bit，还有一个bit没有利用，我们不妨用它来记录每个块被realloc的次数，在第偶数次时，额外分配一些padding。

- 进一步地，观察块的结构：

  ![image-20211208235612215](https://img.i207m.top/2021/12_b72d9e25522da6d188116f5cae1bb614.png)
  
  注意到我们还有很多空闲的bit，以后的改进可以思考如何利用这些bit维护更多信息。

## 测试结果

速度可达 libc baseline 的 190%，同时内存利用率也很优秀。

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%    5694  0.000278 20467
 1       yes   98%    5848  0.000255 22933
 2       yes   99%    6648  0.000380 17495
 3       yes   99%    5380  0.000879  6120
 4       yes   99%   14400  0.000325 44308
 5       yes   96%    4800  0.000859  5587
 6       yes   95%    4800  0.000772  6214
 7       yes   96%   12000  0.000760 15779
 8       yes   89%   24000  0.000803 29880
 9       yes   99%   14401  0.000225 64061
10       yes   86%   14401  0.000234 61438
Total          96%  112372  0.005772 19469

Perf index = 58 (util) + 40 (thru) = 98/100
```


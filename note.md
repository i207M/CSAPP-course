注意是32位机器，指针大小4

使用segregated free list

解读rep文件：
a allocate (index) (size)
r reallocate (index) (size)
f free (index)

```
Results for libc malloc:
trace  valid  util     ops      secs  Kops
 0       yes    0%    5694  0.000507 11240
 1       yes    0%    5848  0.000358 16340
 2       yes    0%    6648  0.001075  6182
 3       yes    0%    5380  0.001083  4969
 4       yes    0%   14400  0.000627 22952
 5       yes    0%    4800  0.001353  3548
 6       yes    0%    4800  0.001004  4780
 7       yes    0%   12000  0.000737 16293
 8       yes    0%   24000  0.001112 21573
 9       yes    0%   14401  0.001999  7203
10       yes    0%   14401  0.000485 29693
Total           0%  112372  0.010340 10867
```

1 << 12
```
 0       yes   97%    5694  0.000547 10411
 1       yes   99%    5848  0.000541 10818
 2       yes   99%    6648  0.000632 10522
 3       yes   99%    5380  0.000527 10207
 4       yes   99%   14400  0.000937 15363
 5       yes   94%    4800  0.000567  8466
 6       yes   91%    4800  0.000565  8497
 7       yes   95%   12000  0.000768 15635
 8       yes   88%   24000  0.005567  4311
 9       yes   99%   14401  0.000458 31423
10       yes   98%   14401  0.000332 43337
Total          96%  112372  0.011441  9822

Perf index = 58 (util) + 39 (thru) = 97/100
```

1 << 13

```
trace  valid  util     ops      secs  Kops
 0       yes   98%    5694  0.000478 11912
 1       yes   98%    5848  0.000477 12257
 2       yes   98%    6648  0.000553 12033
 3       yes   99%    5380  0.000452 11897
 4       yes   99%   14400  0.000848 16977
 5       yes   93%    4800  0.000568  8443
 6       yes   91%    4800  0.000568  8446
 7       yes   96%   12000  0.000783 15332
 8       yes   89%   24000  0.001488 16127
 9       yes   99%   14401  0.000467 30831
10       yes   86%   14401  0.000422 34142
Total          95%  112372  0.007105 15817

Perf index = 57 (util) + 40 (thru) = 97/100
```

第10个点realloc2：reallocate一大段，然后盖一个小的，然后再reallocate
第8个点binary2：先allocate 112+16，free，再allocate 128
现在Kops很高，我们可以尝试牺牲一点性能，来换util

需要做的优化：

- 去掉footer  难！先不做了。
- 还剩一个bit，可以用它来实现：当某个块第偶数次reallocate时，加上padding  先不做了！

现在，加速不是我们的主要目的。

对于每个块的结构：

已分配的，开头是块大小，~~结尾没有~~结尾也是。
开头块大小的最后一bit记录是否分配，倒数第二bit记录前一块是否分配
每个block的ptr指向开头

未分配的，开头是块大小，其次是前向指针，然后是后向指针，结尾是块大小

当realloc块变小时，没有做操作。可能导致空间利用率低。打印出来内存结构看看！
为什么把realloc的结果全部分配？

Mine

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%    5694  0.000278 20467
 1       yes   98%    5848  0.000255 22933
 2       yes   99%    6648  0.000380 17495
 3       yes   99%    5380  0.000879  6120
 4       yes   99%   14400  0.000325 44308
 5       yes   96%    4800  0.000859  5587
 6       yes   95%    4800  0.000772  6214
 7       yes   96%   12000  0.000760 15779
 8       yes   89%   24000  0.000803 29880
 9       yes   99%   14401  0.000225 64061
10       yes   86%   14401  0.000234 61438
Total          96%  112372  0.005772 19469

Perf index = 58 (util) + 40 (thru) = 98/100
```

```
Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%    5694  0.000517 11014
 1       yes   99%    5848  0.000405 14432
 2       yes   99%    6648  0.000454 14634
 3       yes   99%    5380  0.001193  4509
 4       yes   99%   14400  0.000324 44472
 5       yes   95%    4800  0.000846  5676
 6       yes   95%    4800  0.000781  6144
 7       yes   95%   12000  0.000712 16863
 8       yes   88%   24000  0.004999  4801
 9       yes   99%   14401  0.000259 55688
10       yes   98%   14401  0.000267 53876
Total          97%  112372  0.010757 10447

Perf index = 58 (util) + 40 (thru) = 98/100
```
